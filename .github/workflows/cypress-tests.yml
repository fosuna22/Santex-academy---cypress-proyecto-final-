name: QA Report (Cypress + Mochawesome)

on:
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch a ejecutar'
        required: true
        default: 'main'
      tag:
        description: 'Tag/grep para las pruebas (opcional, ej: @login)'
        required: false
        default: ''

jobs:
  cypress-and-report:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install deps
        run: |
          npm ci
          # Reporter√≠a Mochawesome
          npm i -D cypress-multi-reporters mochawesome mochawesome-merge mochawesome-report-generator
          # Utilidades
          sudo apt-get update && sudo apt-get install -y jq

      - name: Reporter config (Mochawesome ‚Üí JSON)
        run: |
          rm -rf cypress/results || true
          mkdir -p cypress/results
          cat > reporter-config.json << 'JSON'
          {
            "reporterEnabled": "mochawesome",
            "mochawesomeReporterOptions": {
              "reportDir": "cypress/results",
              "overwrite": false,
              "quiet": true,
              "html": false,
              "json": true
            }
          }
          JSON

      - name: Run Cypress (genera mochawesome *.json)
        env:
          TEST_TAG: ${{ github.event.inputs.tag }}
          CI: "1"
        run: |
          set -euxo pipefail

          EXTRA_ARGS=""
          if [ -n "$TEST_TAG" ]; then
            echo "Ejecutando con filtro: $TEST_TAG"
            # Si us√°s cypress-grep, descoment√°:
            # EXTRA_ARGS="--env grepTags=$TEST_TAG"
            # O filtr√° por spec si prefer√≠s:
            # EXTRA_ARGS="--spec cypress/e2e/${TEST_TAG}.cy.js"
          fi

          # Ejecuta Cypress con cypress-multi-reporters usando Mochawesome
          npx cypress run \
            --reporter cypress-multi-reporters \
            --reporter-options "configFile=reporter-config.json" \
            $EXTRA_ARGS || true   # no rompemos el job por fallas de tests

          # Validaci√≥n m√≠nima: ¬øhay al menos un JSON de mochawesome?
          test -n "$(ls -1 cypress/results/*.json 2>/dev/null | head -n1)" || (echo "Mochawesome no gener√≥ JSON" && exit 1)

      - name: Merge mochawesome ‚Üí merged.json
        run: |
          # Une todos los JSON de mochawesome en uno solo
          npx mochawesome-merge cypress/results/*.json > cypress/results/merged.json
          test -s cypress/results/merged.json

      - name: (Opcional) Generar HTML a partir del merge
        run: |
          npx marge cypress/results/merged.json \
            --reportDir cypress/results \
            --inline

      - name: Crear summary.json (total, passed, failed, pending, duration, passedTests, failedTests)
        run: |
          set -euo pipefail
          MERGED="cypress/results/merged.json"

          # Totales a partir de la estructura mochawesome-merge
          TOTAL=$(jq -r '.stats.tests // ([..|objects|select(has("tests"))|.tests[]?|select(.state!="pending")]|length // 0)' "$MERGED")
          PASSED=$(jq -r '[..|objects|select(has("tests"))|.tests[]?|select(.state=="passed" or .pass==true)]|length' "$MERGED")
          FAILED=$(jq -r '[..|objects|select(has("tests"))|.tests[]?|select(.state=="failed" or .fail==true)]|length' "$MERGED")
          PENDING=$(jq -r '[..|objects|select(has("tests"))|.tests[]?|select(.state=="pending")]|length' "$MERGED")
          DURATION=$(jq -r '.stats.duration // ([..|objects|select(has("tests"))|.tests[]?|.duration] | add // 0)' "$MERGED")

          PASSED_LIST=$(jq -c '[..
            | objects
            | select(has("tests"))
            | .tests[]?
            | select(.state=="passed" or .pass==true)
            | {
                fullTitle: (.fullTitle // .title // ""),
                file: (.file // .fullFile // ""),
                duration: (.duration // 0)
              }
          ]' "$MERGED")

          FAILED_LIST=$(jq -c '[..
            | objects
            | select(has("tests"))
            | .tests[]?
            | select(.state=="failed" or .fail==true)
            | {
                fullTitle: (.fullTitle // .title // ""),
                file: (.file // .fullFile // ""),
                duration: (.duration // 0),
                error: (.err.message // .err // .error // "")
              }
          ]' "$MERGED")

          # Resumen final para el webhook
          jq -n \
            --argjson total      "$TOTAL" \
            --argjson passed     "$PASSED" \
            --argjson failed     "$FAILED" \
            --argjson pending    "$PENDING" \
            --argjson duration   "$DURATION" \
            --argjson passedArr  "$PASSED_LIST" \
            --argjson failedArr  "$FAILED_LIST" \
            '{
              total: $total,
              passed: $passed,
              failed: $failed,
              pending: $pending,
              durationMs: $duration,
              passedTests: $passedArr,
              failedTests: $failedArr
            }' > cypress/results/summary.json

          echo "Resumen:"
          jq . cypress/results/summary.json

      - name: POST summary.json a n8n
        env:
          WEBHOOK_URL: "https://curnson8ntechpurpose.app.n8n.cloud/webhook/0f51690c-9699-42e8-9b91-df35bedf8eff"
        continue-on-error: true
        run: |
          set +e  # No fallar en errores
          
          echo "üîç Iniciando env√≠o al webhook..."
          echo "URL: $WEBHOOK_URL"
          
          # Verificar que el archivo summary.json existe
          if [ ! -f "cypress/results/summary.json" ]; then
            echo "‚ö†Ô∏è No se encontr√≥ summary.json, saltando env√≠o al webhook"
            exit 0
          fi
          
          # Validar que el JSON es v√°lido
          if ! jq empty cypress/results/summary.json 2>/dev/null; then
            echo "‚ùå El archivo summary.json no es un JSON v√°lido"
            cat cypress/results/summary.json
            exit 0
          fi
          
          # Mostrar tama√±o y preview del JSON
          echo "üìÑ Tama√±o del archivo: $(wc -c < cypress/results/summary.json) bytes"
          echo "üìã Preview del JSON (primeras 500 caracteres):"
          head -c 500 cypress/results/summary.json
          echo ""
          echo ""
          
          # Probar primero con un GET para verificar que el webhook existe
          echo "üîç Verificando webhook (GET)..."
          TEST_RESPONSE=$(curl -sS -w "\n%{http_code}" -X GET "$WEBHOOK_URL" 2>&1 || echo "ERROR")
          echo "Respuesta GET: $TEST_RESPONSE"
          
          # Enviar al webhook con m√°s informaci√≥n de debugging
          echo "üì§ Enviando POST al webhook..."
          
          # Mostrar el contenido del archivo
          echo "üì¶ Contenido del archivo summary.json:"
          cat cypress/results/summary.json | jq . || cat cypress/results/summary.json
          echo ""
          
          # Verificar el tama√±o del archivo
          FILE_SIZE=$(wc -c < cypress/results/summary.json)
          echo "üìè Tama√±o del archivo: $FILE_SIZE bytes"
          echo ""
          
          # Leer el JSON y prepararlo para env√≠o
          JSON_DATA=$(cat cypress/results/summary.json)
          
          # M√©todo 1: Enviar JSON directamente (el que deber√≠a funcionar)
          echo "üîÑ M√©todo 1: Enviando JSON directamente en el body..."
          HTTP_CODE=$(curl -sS -w "%{http_code}" -o /tmp/webhook_response1.json \
            -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            --data-raw "$JSON_DATA" 2>&1 | tail -n1)
          
          echo "C√≥digo HTTP m√©todo 1: $HTTP_CODE"
          
          # M√©todo 2: Envolver el JSON en un objeto con campo 'data'
          echo ""
          echo "üîÑ M√©todo 2: Enviando JSON envuelto en objeto con campo 'data'..."
          WRAPPED_JSON=$(echo "$JSON_DATA" | jq -c '{data: .}')
          echo "JSON envuelto: $WRAPPED_JSON"
          
          HTTP_CODE2=$(curl -sS -w "%{http_code}" -o /tmp/webhook_response2.json \
            -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            --data-raw "$WRAPPED_JSON" 2>&1 | tail -n1)
          
          echo "C√≥digo HTTP m√©todo 2: $HTTP_CODE2"
          
          # M√©todo 3: Enviar como campo 'body' dentro de un objeto
          echo ""
          echo "üîÑ M√©todo 3: Enviando JSON en campo 'body'..."
          BODY_JSON=$(echo "$JSON_DATA" | jq -c '{body: .}')
          echo "JSON con campo body: $BODY_JSON"
          
          HTTP_CODE3=$(curl -sS -w "%{http_code}" -o /tmp/webhook_response3.json \
            -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            --data-raw "$BODY_JSON" 2>&1 | tail -n1)
          
          echo "C√≥digo HTTP m√©todo 3: $HTTP_CODE3"
          
          # M√©todo 4: Enviar el archivo directamente con --data-binary
          echo ""
          echo "üîÑ M√©todo 4: Enviando archivo con --data-binary..."
          HTTP_CODE4=$(curl -sS -w "%{http_code}" -o /tmp/webhook_response4.json \
            -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            --data-binary "@cypress/results/summary.json" 2>&1 | tail -n1)
          
          echo "C√≥digo HTTP m√©todo 4: $HTTP_CODE4"
          
          # Mostrar resumen
          echo ""
          echo "üìä Resumen de intentos:"
          echo "  M√©todo 1 (JSON directo): $HTTP_CODE"
          echo "  M√©todo 2 (campo 'data'): $HTTP_CODE2"
          echo "  M√©todo 3 (campo 'body'): $HTTP_CODE3"
          echo "  M√©todo 4 (--data-binary): $HTTP_CODE4"
          
          # Usar el c√≥digo HTTP del m√©todo que funcion√≥ (o el primero)
          HTTP_CODE=$HTTP_CODE
          
          echo ""
          echo "üí° Nota: Revisa en n8n qu√© m√©todo recibi√≥ los datos correctamente"
          echo "   Los m√©todos 2 y 3 envuelven el JSON en un objeto, lo cual puede ser necesario"
          echo "   dependiendo de c√≥mo est√© configurado el webhook en n8n."
          echo ""
          echo "HTTP_CODE=$HTTP_CODE"
          
          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            echo "‚úÖ Webhook enviado exitosamente (c√≥digo: $HTTP_CODE)"
            if [ -f /tmp/webhook_response.json ]; then
              echo "Respuesta del servidor:"
              cat /tmp/webhook_response.json | head -c 500 || true
            fi
          else
            echo "‚ö†Ô∏è Webhook retorn√≥ c√≥digo $HTTP_CODE"
            if [ -f /tmp/webhook_response.json ]; then
              echo "Respuesta del servidor:"
              cat /tmp/webhook_response.json || true
            fi
            echo ""
            echo "üí° Posibles causas del 404:"
            echo "   - El webhook no est√° activo en n8n"
            echo "   - La URL del webhook es incorrecta"
            echo "   - El webhook requiere autenticaci√≥n adicional"
            echo "   - El m√©todo HTTP no es el esperado (n8n puede requerir GET en lugar de POST)"
            # No fallar el workflow, solo mostrar advertencia
            exit 0
          fi

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: cypress-mochawesome-results
          path: |
            reporter-config.json
            cypress/results/*.json
            cypress/results/*.html
